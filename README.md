ECS 165A Milestone #1

by: Austin Lew, Keon Sadeghi, Wanzhu Zheng, Aryan Punjani, Alex Amiri

Our goal as a group is to design a database system based on a simplified L-Store from scratch alongside a hybrid transactional analytical processing database. This project is split into three parts, each one being focused on a specific milestone that we are attempting to reach as a group to steadily build and complete our database systems. We aim to take risks with this project in order to test the boundaries to see how complex and fast we can make this database run.

We start by looking at the query function and look at all the following code blocks that we've developed in order to hit the ground running on our database systems:

One of the more important tools that we use in the query is the delete function. The goal of this function is to look for a specified RID/key which stands for record identifier. The delete function will search for an RID and then will use both a try and except function to check if the key has been successfully deleted. Try will print nothing if the key was able to get deleted, while except on the other hand would print a statement if the key could not be found or maybe it was locked by another part of the database for receiving access.

Another important function to look at closely is for inserting in a query. The insert function will work to accept any new information or data into the database and to place it in the most relevant location. This typically will work to bring in specified columns that can be easily accessible later. Similarly to delete, it will use RIDs/keys in order to successfully collect the new information into the database. It will use a if and else statement in order to return a string of true or false that will return true if the data was successfully inserted and false if there was an error of some kind placing it or it's incompatible with the database.

Increment is another useful query function that works to increase the size of our keys or columns in order to increase the efficiency of the database. The RIDs/keys and columns all have separate calls that makes it easier to specify which portion of the database is trying to be incremented specifically. Just like with the insert function, it will also use true and false in order to test whether or not the keys or columns can be incremented in the setting it is presented in.

The query function would also not be complete without featuring a sort of select function so that the database can match any key words being thrown its way when needed to examine or collect any sort of information. The function will also look through the byte array in order to check if the data can be recorded from the base page. It uses an interesting technique by putting the information the function selects in two different temporary lists depending on if it returns 1 or 0. If 1 is returned, then the byte information is placed into a specific list. If 0 is returned, then nothing is returned and that information is put into an irrelevant list.

The update function of our database within a query is another great tool that we use when processing information through the database. In a database, information is constantly changing at every turn so there should always be some sort of function to update any numbers in the event that it is no longer up to date. For this query function in particular it runs multiple try and except functions, ultimately with the goal of either returning the information as true or false. True, meaning that the information was successfully updated, and false, meaning that the information could either not be accessed correctly or it could not be updated for a certain reason either. Thus, having an update function is very useful to keep everything running with the correct information at all times.

A function that also helps make things run as smoothly as possible within our query function is the sum function. Since we know that the database can hold a bunch of similar or duplicate information, it's important to keep them all grouped up and added together so it doesn't leave the database all congested with the same information. When looking at the code, we use indirection pointers as a way to make sure that the databases' memory is as flexible as it could possibly be when constantly combining and adding information from byte arrays or elsewhere. If an indirection pointer is present within the code, then it can add what's called a tail record to the database which will add upon each other and keep going as it can be fitted. If there isn't one present, then it will use another longer method of recording the summation of the databases' information.

Another important part of this database is the index function and how it uses its code in order to work alongside not only the query function but the whole database as a whole.
